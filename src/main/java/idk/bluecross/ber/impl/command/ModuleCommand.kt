package idk.bluecross.ber.impl.command

import idk.bluecross.ber.api.module.IModule
import idk.bluecross.ber.api.setting.ISetting
import idk.bluecross.ber.impl.module.Module
import idk.bluecross.ber.impl.setting.ModuleSetting
import idk.bluecross.ber.util.ChatUtil
import kotlin.reflect.KProperty
import kotlin.reflect.full.memberProperties
import kotlin.reflect.jvm.isAccessible
import java.lang.Enum.valueOf
import java.lang.RuntimeException

object ModuleCommand : Command("module", "m", subCommands = arrayListOf(
        EnableCommand,
        DisableCommand,
        SettingsCommand
)) {

    override val helpMessage: String = this.subCommands.map { it.names }.toString()
    override fun job(args: Array<String>) {
        sendHelpMessage()
    }

    object EnableCommand : Command("enable", "e") {
        override fun job(modulesToEnable: Array<String>) {
            println("1")
            modulesToEnable.forEach { moduleName ->
                IModule.modules.firstOrNull { it.name.equals(moduleName, true) }?.enable()
                        ?: ChatUtil.sendMessageToPlayer("Module $moduleName not found")
            }
        }

        override val helpMessage: String = "Enable module. Usage: `moduleName(s)`"

    }

    object DisableCommand : Command("disable", "d") {
        override fun job(modulesToDisable: Array<String>) {
            println("2")
            modulesToDisable.forEach { moduleName ->
                IModule.modules.firstOrNull { it.name.equals(moduleName, true) }?.disable()
                        ?: ChatUtil.sendMessageToPlayer("Module $moduleName not found")
            }
        }

        override val helpMessage: String = "Enable module. Usage: `moduleName(s)`"

    }

    object SettingsCommand : Command("setting", "s") {
        override fun job(args: Array<String>) {
            val module = IModule.modules.find { it.name.equals(args[0], true) }!!
            var setting by module.settings.find { it.name.equals(args[1], true) } as ModuleSetting<Any>
            val value = args[2]

            val prevS = setting

            if ((setting.javaClass.genericSuperclass as? Class<*>)?.isEnum == true) {
                setting = ((setting.javaClass.genericSuperclass as? Class<*>)?.enumConstants as Array<Enum<*>>).first { it.name.equals(value,true) }
            } else {
                when (setting::class) {
                    Int::class -> {
                        setting = value.toInt()
                    }

                    Float::class -> {
                        setting = value.toFloat()
                    }

                    Boolean::class -> {
                        setting = value.toBoolean()
                    }

                    String::class -> {
                        setting = value
                    }

                    else -> {
                        throw RuntimeException("Setting type not found!")
                    }
                }
            }
        }

        override val helpMessage: String = "Change module setting. Usage: `module setting value`"
    }

}