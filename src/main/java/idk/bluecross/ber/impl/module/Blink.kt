package idk.bluecross.ber.impl.module

import idk.bluecross.ber.impl.setting.settings.BoolSetting
import idk.bluecross.ber.impl.setting.settings.EnumSetting
import idk.bluecross.ber.util.pasted.PlayerUtil
import idk.bluecross.ber.util.interfaces.Globals.mc
import idk.bluecross.ber.impl.event.PacketSendEvent
import idk.bluecross.ber.util.annotation.annotations.DisableOn
import net.minecraft.client.entity.EntityOtherPlayerMP
import net.minecraft.network.Packet
import net.minecraft.network.play.client.*
import net.minecraftforge.fml.common.eventhandler.SubscribeEvent
import net.minecraftforge.fml.common.gameevent.TickEvent
import org.lwjgl.input.Keyboard
import java.util.LinkedList
import java.util.Queue

@DisableOn(DisableOn.Reason.DISCONNECT)
object Blink : Module("Телепортатор?") {
    enum class PacketMode {
        All {
            override fun shouldCancel(packet: Packet<*>?) = true
        },
        CPacketPlayer {
            override fun shouldCancel(packet: Packet<*>?) = packet is net.minecraft.network.play.client.CPacketPlayer
        },
        Filtered {
            override fun shouldCancel(packet: Packet<*>?) = (
                    !(packet is CPacketChatMessage
                            || packet is CPacketConfirmTeleport
                            || packet is CPacketKeepAlive
                            || packet is CPacketTabComplete
                            || packet is CPacketClientStatus))
        };

        abstract fun shouldCancel(packet: Packet<*>?): Boolean
    }


    var packetMode by EnumSetting(this, "PacketMode", PacketMode.Filtered)
    var smartEnabling by BoolSetting(this, "SmartEnabling", false)

    @SubscribeEvent
    fun checkIsPlayerNear(e: TickEvent.ClientTickEvent) {
        if (mc.world != null && smartEnabling) {
            mc.world.playerEntities.filter { !it.uniqueID.equals(fakePlayer?.uniqueID) }.minBy { it.getDistance(fakePlayer) }?.also { enemy ->
                this.enabled = true
                while (mc.player.getDistance(enemy) >= 1) {
                    if (mc.player.getDistance(enemy) >= 10) break
                }
                this.enabled = false
            }
        }
    }

    val packetQueue: Queue<Packet<*>> = LinkedList()
    var fakePlayer: EntityOtherPlayerMP? = null

    init {
        keybind.key = Keyboard.KEY_B
    }

    override fun onEnable() {
        fakePlayer = PlayerUtil.createFakePlayerAndAddToWorld(mc.player.gameProfile)
    }

    @SubscribeEvent
    fun onPacket(e: PacketSendEvent) {
        if (packetMode.shouldCancel(e.packet)) {
            packetQueue.add(e.packet)
            e.cancel()
        }
    }

    override fun onDisable() {
        if (mc.connection != null) packetQueue.forEach(mc.connection!!::sendPacket)
        PlayerUtil.removeFakePlayer(fakePlayer)
        packetQueue.clear()
    }
}